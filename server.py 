import asyncio
import websockets
import json
import http.server
import socketserver
import threading
from pathlib import Path
import os

# 儲存連線的客戶端
rooms = {}  # {room_code: {'projection': ws, 'controller': ws}}

async def handle_client(websocket, path):
    room_code = None
    client_type = None
    
    try:
        async for message in websocket:
            data = json.loads(message)
            
            # 處理加入房間
            if data['type'] == 'join':
                room_code = data['room']
                client_type = data['client_type']  # 'projection' or 'controller'
                
                if room_code not in rooms:
                    rooms[room_code] = {}
                
                rooms[room_code][client_type] = websocket
                
                # 通知連線成功
                await websocket.send(json.dumps({
                    'type': 'connected',
                    'room': room_code,
                    'client_type': client_type
                }))
                
                print(f"{client_type} joined room {room_code}")
                
                # 如果兩端都連線了,通知雙方
                if 'projection' in rooms[room_code] and 'controller' in rooms[room_code]:
                    for ws in rooms[room_code].values():
                        if ws.open:
                            await ws.send(json.dumps({
                                'type': 'both_connected',
                                'room': room_code
                            }))
            
            # 處理控制指令
            elif data['type'] == 'control':
                if room_code and room_code in rooms:
                    # 從控制端發送到投影端
                    if 'projection' in rooms[room_code]:
                        projection_ws = rooms[room_code]['projection']
                        if projection_ws.open:
                            await projection_ws.send(json.dumps(data))
            
            # 處理遊戲狀態更新
            elif data['type'] == 'game_state':
                if room_code and room_code in rooms:
                    # 從投影端發送到控制端
                    if 'controller' in rooms[room_code]:
                        controller_ws = rooms[room_code]['controller']
                        if controller_ws.open:
                            await controller_ws.send(json.dumps(data))
    
    except websockets.exceptions.ConnectionClosed:
        print(f"Connection closed for {client_type} in room {room_code}")
    finally:
        # 清理連線
        if room_code and room_code in rooms:
            if client_type in rooms[room_code]:
                del rooms[room_code][client_type]
            
            # 如果房間空了,刪除房間
            if not rooms[room_code]:
                del rooms[room_code]
            else:
                # 通知另一端斷線
                for ws in rooms[room_code].values():
                    if ws.open:
                        await ws.send(json.dumps({
                            'type': 'peer_disconnected',
                            'room': room_code
                        }))

def run_http_server():
    """啟動 HTTP 伺服器提供 HTML 檔案"""
    PORT = int(os.environ.get('PORT', 8000))
    
    class MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, directory=str(Path(__file__).parent), **kwargs)
    
    with socketserver.TCPServer(("", PORT), MyHTTPRequestHandler) as httpd:
        print(f"HTTP Server running on port {PORT}")
        httpd.serve_forever()

async def main():
    # 啟動 HTTP 伺服器 (在另一個執行緒)
    http_thread = threading.Thread(target=run_http_server, daemon=True)
    http_thread.start()
    
    # WebSocket 伺服器監聽所有介面
    WS_PORT = int(os.environ.get('WS_PORT', 8765))
    print(f"WebSocket Server starting on port {WS_PORT}")
    
    async with websockets.serve(handle_client, "0.0.0.0", WS_PORT):
        await asyncio.Future()  # 持續運行

if __name__ == "__main__":
    asyncio.run(main())